{"version":3,"sources":["webpack:///./node_modules/@ledgerhq/hw-app-eth/node_modules/rlp/dist/index.js","webpack:///./node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.js","webpack:///./node_modules/@ledgerhq/hw-app-eth/lib-es/utils.js","webpack:///./node_modules/@ledgerhq/errors/dist/index.js"],"names":["Object","defineProperty","exports","value","getLength","decode","encode","BN","input","Array","isArray","output","i","length","push","buf","Buffer","concat","encodeLength","inputBuf","toBuffer","safeParseInt","v","base","slice","Error","parseInt","len","offset","from","hexLength","intToHex","lLength","firstByte","stream","inputBuffer","decoded","_decode","remainder","data","llength","toString","innerRemainder","d","totalLength","isHexPrefixed","str","stripHexPrefix","integer","hex","padToEven","a","intToBuffer","isBuffer","undefined","Uint8Array","isBN","toArray","hexBuffer","startsWith","maybeHexBuffer","remapTransactionRelatedErrors","e","statusCode","Eth","transport","scrambleKey","this","decorateAppAPIMethods","path","boolDisplay","boolChaincode","paths","buffer","alloc","forEach","element","index","writeUInt32BE","send","then","response","result","publicKeyLength","addressLength","publicKey","address","chainCode","rawTxHex","rawTx","toSend","rlpTx","rlpOffset","rlpVrs","maxChunkSize","chunkSize","copy","apduResponse","r","s","arbitraryDataEnabled","erc20ProvisioningNecessary","starkEnabled","version","messageHex","message","sourceTokenAddress","sourceQuantization","destinationTokenAddress","destinationQuantization","sourceVault","destinationVault","amountSell","amountBuy","nonce","timestamp","sourceTokenAddressHex","destinationTokenAddressHex","padStart","transferTokenAddress","transferQuantization","targetPublicKey","amountTransfer","transferTokenAddressHex","targetPublicKeyHex","operationContract","operationQuantization","operationContractHex","splitPath","components","split","number","isNaN","foreach","arr","callback","iterate","array","res","Promise","resolve","errorClasses","deserializers","addCustomErrorDeserializer","name","deserializer","createCustomErrorClass","C","fields","assign","stack","prototype","EthAppPleaseEnableContractData","TransportRaceCondition","TransportError","id","StatusCodes","PIN_REMAINING_ATTEMPTS","INCORRECT_LENGTH","MISSING_CRITICAL_PARAMETER","COMMAND_INCOMPATIBLE_FILE_STRUCTURE","SECURITY_STATUS_NOT_SATISFIED","CONDITIONS_OF_USE_NOT_SATISFIED","INCORRECT_DATA","NOT_ENOUGH_MEMORY_SPACE","REFERENCED_DATA_NOT_FOUND","FILE_ALREADY_EXISTS","INCORRECT_P1_P2","INS_NOT_SUPPORTED","CLA_NOT_SUPPORTED","TECHNICAL_PROBLEM","OK","MEMORY_PROBLEM","NO_EF_SELECTED","INVALID_OFFSET","FILE_NOT_FOUND","INCONSISTENT_FILE","ALGORITHM_NOT_SUPPORTED","INVALID_KCV","CODE_NOT_INITIALIZED","ACCESS_CONDITION_NOT_FULFILLED","CONTRADICTION_SECRET_CODE_STATUS","CONTRADICTION_INVALIDATION","CODE_BLOCKED","MAX_VALUE_REACHED","GP_AUTH_FAILED","LICENSING","HALTED","getAltStatusMessage","code","TransportStatusError","statusText","keys","find","k","smsg","statusCodeStr"],"mappings":"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","file":"js/chunk-296036d3.b94337eb.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLength = exports.decode = exports.encode = void 0;\nvar BN = require(\"bn.js\");\n/**\n * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP\n * This function takes in a data, convert it to buffer if not, and a length for recursion\n * @param input - will be converted to buffer\n * @returns returns buffer of encoded data\n **/\nfunction encode(input) {\n    if (Array.isArray(input)) {\n        var output = [];\n        for (var i = 0; i < input.length; i++) {\n            output.push(encode(input[i]));\n        }\n        var buf = Buffer.concat(output);\n        return Buffer.concat([encodeLength(buf.length, 192), buf]);\n    }\n    else {\n        var inputBuf = toBuffer(input);\n        return inputBuf.length === 1 && inputBuf[0] < 128\n            ? inputBuf\n            : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);\n    }\n}\nexports.encode = encode;\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n * @param base The base to parse the integer into\n */\nfunction safeParseInt(v, base) {\n    if (v.slice(0, 2) === '00') {\n        throw new Error('invalid RLP: extra zeros');\n    }\n    return parseInt(v, base);\n}\nfunction encodeLength(len, offset) {\n    if (len < 56) {\n        return Buffer.from([len + offset]);\n    }\n    else {\n        var hexLength = intToHex(len);\n        var lLength = hexLength.length / 2;\n        var firstByte = intToHex(offset + 55 + lLength);\n        return Buffer.from(firstByte + hexLength, 'hex');\n    }\n}\nfunction decode(input, stream) {\n    if (stream === void 0) { stream = false; }\n    if (!input || input.length === 0) {\n        return Buffer.from([]);\n    }\n    var inputBuffer = toBuffer(input);\n    var decoded = _decode(inputBuffer);\n    if (stream) {\n        return decoded;\n    }\n    if (decoded.remainder.length !== 0) {\n        throw new Error('invalid remainder');\n    }\n    return decoded.data;\n}\nexports.decode = decode;\n/**\n * Get the length of the RLP input\n * @param input\n * @returns The length of the input or an empty Buffer if no input\n */\nfunction getLength(input) {\n    if (!input || input.length === 0) {\n        return Buffer.from([]);\n    }\n    var inputBuffer = toBuffer(input);\n    var firstByte = inputBuffer[0];\n    if (firstByte <= 0x7f) {\n        return inputBuffer.length;\n    }\n    else if (firstByte <= 0xb7) {\n        return firstByte - 0x7f;\n    }\n    else if (firstByte <= 0xbf) {\n        return firstByte - 0xb6;\n    }\n    else if (firstByte <= 0xf7) {\n        // a list between  0-55 bytes long\n        return firstByte - 0xbf;\n    }\n    else {\n        // a list  over 55 bytes long\n        var llength = firstByte - 0xf6;\n        var length = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);\n        return llength + length;\n    }\n}\nexports.getLength = getLength;\n/** Decode an input with RLP */\nfunction _decode(input) {\n    var length, llength, data, innerRemainder, d;\n    var decoded = [];\n    var firstByte = input[0];\n    if (firstByte <= 0x7f) {\n        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n        return {\n            data: input.slice(0, 1),\n            remainder: input.slice(1),\n        };\n    }\n    else if (firstByte <= 0xb7) {\n        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n        // The range of the first byte is [0x80, 0xb7]\n        length = firstByte - 0x7f;\n        // set 0x80 null to 0\n        if (firstByte === 0x80) {\n            data = Buffer.from([]);\n        }\n        else {\n            data = input.slice(1, length);\n        }\n        if (length === 2 && data[0] < 0x80) {\n            throw new Error('invalid rlp encoding: byte must be less 0x80');\n        }\n        return {\n            data: data,\n            remainder: input.slice(length),\n        };\n    }\n    else if (firstByte <= 0xbf) {\n        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),\n        // followed by the length, followed by the string\n        llength = firstByte - 0xb6;\n        if (input.length - 1 < llength) {\n            throw new Error('invalid RLP: not enough bytes for string length');\n        }\n        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);\n        if (length <= 55) {\n            throw new Error('invalid RLP: expected string length to be greater than 55');\n        }\n        data = input.slice(llength, length + llength);\n        if (data.length < length) {\n            throw new Error('invalid RLP: not enough bytes for string');\n        }\n        return {\n            data: data,\n            remainder: input.slice(length + llength),\n        };\n    }\n    else if (firstByte <= 0xf7) {\n        // a list between  0-55 bytes long\n        length = firstByte - 0xbf;\n        innerRemainder = input.slice(1, length);\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(length),\n        };\n    }\n    else {\n        // a list  over 55 bytes long\n        llength = firstByte - 0xf6;\n        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);\n        var totalLength = llength + length;\n        if (totalLength > input.length) {\n            throw new Error('invalid rlp: total length is larger than the data');\n        }\n        innerRemainder = input.slice(llength, totalLength);\n        if (innerRemainder.length === 0) {\n            throw new Error('invalid rlp, List has a invalid length');\n        }\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(totalLength),\n        };\n    }\n}\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str) {\n    return str.slice(0, 2) === '0x';\n}\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform an integer into its hexadecimal value */\nfunction intToHex(integer) {\n    if (integer < 0) {\n        throw new Error('Invalid integer as argument, must be unsigned!');\n    }\n    var hex = integer.toString(16);\n    return hex.length % 2 ? \"0\" + hex : hex;\n}\n/** Pad a string to be even */\nfunction padToEven(a) {\n    return a.length % 2 ? \"0\" + a : a;\n}\n/** Transform an integer into a Buffer */\nfunction intToBuffer(integer) {\n    var hex = intToHex(integer);\n    return Buffer.from(hex, 'hex');\n}\n/** Transform anything into a Buffer */\nfunction toBuffer(v) {\n    if (!Buffer.isBuffer(v)) {\n        if (typeof v === 'string') {\n            if (isHexPrefixed(v)) {\n                return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');\n            }\n            else {\n                return Buffer.from(v);\n            }\n        }\n        else if (typeof v === 'number' || typeof v === 'bigint') {\n            if (!v) {\n                return Buffer.from([]);\n            }\n            else {\n                return intToBuffer(v);\n            }\n        }\n        else if (v === null || v === undefined) {\n            return Buffer.from([]);\n        }\n        else if (v instanceof Uint8Array) {\n            return Buffer.from(v);\n        }\n        else if (BN.isBN(v)) {\n            // converts a BN to a Buffer\n            return Buffer.from(v.toArray());\n        }\n        else {\n            throw new Error('invalid type');\n        }\n    }\n    return v;\n}\n//# sourceMappingURL=index.js.map","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport { BigNumber } from \"bignumber.js\";\nimport { encode, decode } from \"rlp\";\n\nfunction hexBuffer(str) {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str) {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\"Please enable Contract data on the Ethereum app Settings\");\n  }\n\n  return e;\n};\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\n\n\nexport default class Eth {\n  constructor(transport, scrambleKey = \"w0w\") {\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"provideERC20TokenInformation\", \"signTransaction\", \"signPersonalMessage\", \"getAppConfiguration\", \"starkGetPublicKey\", \"starkSignOrder\", \"starkSignTransfer\", \"starkProvideQuantum\"], scrambleKey);\n  }\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n\n\n  getAddress(path, boolDisplay, boolChaincode) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer).then(response => {\n      let result = {};\n      let publicKeyLength = response[0];\n      let addressLength = response[1 + publicKeyLength];\n      result.publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n      result.address = \"0x\" + response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString(\"ascii\");\n\n      if (boolChaincode) {\n        result.chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString(\"hex\");\n      }\n\n      return result;\n    });\n  }\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n\n\n  provideERC20TokenInformation({\n    data\n  }) {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n        // we return a flag to know if the call was effective or not\n        return false;\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n\n\n  signTransaction(path, rawTxHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response; // Check if the TX is encoded following EIP 155\n\n    let rlpTx = decode(rawTx);\n    let rlpOffset = 0;\n\n    if (rlpTx.length > 6) {\n      let rlpVrs = encode(rlpTx.slice(-3));\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n    }\n\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response.slice(0, 1).toString(\"hex\");\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    }, e => {\n      throw remapTransactionRelatedErrors(e);\n    });\n  }\n  /**\n   */\n\n\n  getAppConfiguration() {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\n  eth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n\n  signPersonalMessage(path, messageHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n\n\n  starkGetPublicKey(path, boolDisplay) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer).then(response => {\n      return response.slice(0, response.length - 2);\n    });\n  }\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignOrder(path, sourceTokenAddress, sourceQuantization, destinationTokenAddress, destinationQuantization, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x01, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignTransfer(path, transferTokenAddress, transferQuantization, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp) {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x02, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n\n\n  starkProvideQuantum(operationContract, operationQuantization) {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n\n    Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting Stark extensions\n        return false;\n      }\n\n      throw e;\n    });\n  }\n\n}\n//# sourceMappingURL=Eth.js.map","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\nexport function defer() {\n  let resolve, reject;\n  let promise = new Promise(function (success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n\n  return {\n    promise,\n    resolve,\n    reject\n  };\n} // TODO use bip32-path library\n\nexport function splitPath(path) {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n\n    result.push(number);\n  });\n  return result;\n} // TODO use async await\n\nexport function eachSeries(arr, fun) {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\nexport function foreach(arr, callback) {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else return callback(array[index], index).then(function (res) {\n      result.push(res);\n      return iterate(index + 1, array, result);\n    });\n  }\n\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\nexport function doIf(condition, callback) {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\nexport function asyncWhile(predicate, callback) {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then(res => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n\n  return Promise.resolve([]).then(iterate);\n}\n//# sourceMappingURL=utils.js.map","/* eslint-disable no-continue */\r\n/* eslint-disable no-param-reassign */\r\n/* eslint-disable no-prototype-builtins */\r\nvar errorClasses = {};\r\nvar deserializers = {};\r\nvar addCustomErrorDeserializer = function (name, deserializer) {\r\n    deserializers[name] = deserializer;\r\n};\r\nvar createCustomErrorClass = function (name) {\r\n    var C = function CustomError(message, fields) {\r\n        Object.assign(this, fields);\r\n        this.name = name;\r\n        this.message = message || name;\r\n        this.stack = new Error().stack;\r\n    };\r\n    C.prototype = new Error();\r\n    errorClasses[name] = C;\r\n    return C;\r\n};\r\n// inspired from https://github.com/programble/errio/blob/master/index.js\r\nvar deserializeError = function (object) {\r\n    if (typeof object === \"object\" && object) {\r\n        try {\r\n            // $FlowFixMe FIXME HACK\r\n            var msg = JSON.parse(object.message);\r\n            if (msg.message && msg.name) {\r\n                object = msg;\r\n            }\r\n        }\r\n        catch (e) {\r\n            // nothing\r\n        }\r\n        var error = void 0;\r\n        if (typeof object.name === \"string\") {\r\n            var name_1 = object.name;\r\n            var des = deserializers[name_1];\r\n            if (des) {\r\n                error = des(object);\r\n            }\r\n            else {\r\n                var constructor = name_1 === \"Error\" ? Error : errorClasses[name_1];\r\n                if (!constructor) {\r\n                    console.warn(\"deserializing an unknown class '\" + name_1 + \"'\");\r\n                    constructor = createCustomErrorClass(name_1);\r\n                }\r\n                error = Object.create(constructor.prototype);\r\n                try {\r\n                    for (var prop in object) {\r\n                        if (object.hasOwnProperty(prop)) {\r\n                            error[prop] = object[prop];\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // sometimes setting a property can fail (e.g. .name)\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            error = new Error(object.message);\r\n        }\r\n        if (!error.stack && Error.captureStackTrace) {\r\n            Error.captureStackTrace(error, deserializeError);\r\n        }\r\n        return error;\r\n    }\r\n    return new Error(String(object));\r\n};\r\n// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js\r\nvar serializeError = function (value) {\r\n    if (!value)\r\n        return value;\r\n    if (typeof value === \"object\") {\r\n        return destroyCircular(value, []);\r\n    }\r\n    if (typeof value === \"function\") {\r\n        return \"[Function: \" + (value.name || \"anonymous\") + \"]\";\r\n    }\r\n    return value;\r\n};\r\n// https://www.npmjs.com/package/destroy-circular\r\nfunction destroyCircular(from, seen) {\r\n    var to = {};\r\n    seen.push(from);\r\n    for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        var value = from[key];\r\n        if (typeof value === \"function\") {\r\n            continue;\r\n        }\r\n        if (!value || typeof value !== \"object\") {\r\n            to[key] = value;\r\n            continue;\r\n        }\r\n        if (seen.indexOf(from[key]) === -1) {\r\n            to[key] = destroyCircular(from[key], seen.slice(0));\r\n            continue;\r\n        }\r\n        to[key] = \"[Circular]\";\r\n    }\r\n    if (typeof from.name === \"string\") {\r\n        to.name = from.name;\r\n    }\r\n    if (typeof from.message === \"string\") {\r\n        to.message = from.message;\r\n    }\r\n    if (typeof from.stack === \"string\") {\r\n        to.stack = from.stack;\r\n    }\r\n    return to;\r\n}\n\nvar AccountNameRequiredError = createCustomErrorClass(\"AccountNameRequired\");\r\nvar AccountNotSupported = createCustomErrorClass(\"AccountNotSupported\");\r\nvar AmountRequired = createCustomErrorClass(\"AmountRequired\");\r\nvar BluetoothRequired = createCustomErrorClass(\"BluetoothRequired\");\r\nvar BtcUnmatchedApp = createCustomErrorClass(\"BtcUnmatchedApp\");\r\nvar CantOpenDevice = createCustomErrorClass(\"CantOpenDevice\");\r\nvar CashAddrNotSupported = createCustomErrorClass(\"CashAddrNotSupported\");\r\nvar CurrencyNotSupported = createCustomErrorClass(\"CurrencyNotSupported\");\r\nvar DeviceAppVerifyNotSupported = createCustomErrorClass(\"DeviceAppVerifyNotSupported\");\r\nvar DeviceGenuineSocketEarlyClose = createCustomErrorClass(\"DeviceGenuineSocketEarlyClose\");\r\nvar DeviceNotGenuineError = createCustomErrorClass(\"DeviceNotGenuine\");\r\nvar DeviceOnDashboardExpected = createCustomErrorClass(\"DeviceOnDashboardExpected\");\r\nvar DeviceOnDashboardUnexpected = createCustomErrorClass(\"DeviceOnDashboardUnexpected\");\r\nvar DeviceInOSUExpected = createCustomErrorClass(\"DeviceInOSUExpected\");\r\nvar DeviceHalted = createCustomErrorClass(\"DeviceHalted\");\r\nvar DeviceNameInvalid = createCustomErrorClass(\"DeviceNameInvalid\");\r\nvar DeviceSocketFail = createCustomErrorClass(\"DeviceSocketFail\");\r\nvar DeviceSocketNoBulkStatus = createCustomErrorClass(\"DeviceSocketNoBulkStatus\");\r\nvar DisconnectedDevice = createCustomErrorClass(\"DisconnectedDevice\");\r\nvar DisconnectedDeviceDuringOperation = createCustomErrorClass(\"DisconnectedDeviceDuringOperation\");\r\nvar EnpointConfigError = createCustomErrorClass(\"EnpointConfig\");\r\nvar EthAppPleaseEnableContractData = createCustomErrorClass(\"EthAppPleaseEnableContractData\");\r\nvar FeeEstimationFailed = createCustomErrorClass(\"FeeEstimationFailed\");\r\nvar FirmwareNotRecognized = createCustomErrorClass(\"FirmwareNotRecognized\");\r\nvar HardResetFail = createCustomErrorClass(\"HardResetFail\");\r\nvar InvalidXRPTag = createCustomErrorClass(\"InvalidXRPTag\");\r\nvar InvalidAddress = createCustomErrorClass(\"InvalidAddress\");\r\nvar InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass(\"InvalidAddressBecauseDestinationIsAlsoSource\");\r\nvar LatestMCUInstalledError = createCustomErrorClass(\"LatestMCUInstalledError\");\r\nvar UnknownMCU = createCustomErrorClass(\"UnknownMCU\");\r\nvar LedgerAPIError = createCustomErrorClass(\"LedgerAPIError\");\r\nvar LedgerAPIErrorWithMessage = createCustomErrorClass(\"LedgerAPIErrorWithMessage\");\r\nvar LedgerAPINotAvailable = createCustomErrorClass(\"LedgerAPINotAvailable\");\r\nvar ManagerAppAlreadyInstalledError = createCustomErrorClass(\"ManagerAppAlreadyInstalled\");\r\nvar ManagerAppRelyOnBTCError = createCustomErrorClass(\"ManagerAppRelyOnBTC\");\r\nvar ManagerAppDepInstallRequired = createCustomErrorClass(\"ManagerAppDepInstallRequired\");\r\nvar ManagerAppDepUninstallRequired = createCustomErrorClass(\"ManagerAppDepUninstallRequired\");\r\nvar ManagerDeviceLockedError = createCustomErrorClass(\"ManagerDeviceLocked\");\r\nvar ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass(\"ManagerFirmwareNotEnoughSpace\");\r\nvar ManagerNotEnoughSpaceError = createCustomErrorClass(\"ManagerNotEnoughSpace\");\r\nvar ManagerUninstallBTCDep = createCustomErrorClass(\"ManagerUninstallBTCDep\");\r\nvar NetworkDown = createCustomErrorClass(\"NetworkDown\");\r\nvar NoAddressesFound = createCustomErrorClass(\"NoAddressesFound\");\r\nvar NotEnoughBalance = createCustomErrorClass(\"NotEnoughBalance\");\r\nvar NotEnoughBalanceToDelegate = createCustomErrorClass(\"NotEnoughBalanceToDelegate\");\r\nvar NotEnoughBalanceInParentAccount = createCustomErrorClass(\"NotEnoughBalanceInParentAccount\");\r\nvar NotEnoughSpendableBalance = createCustomErrorClass(\"NotEnoughSpendableBalance\");\r\nvar NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass(\"NotEnoughBalanceBecauseDestinationNotCreated\");\r\nvar NoAccessToCamera = createCustomErrorClass(\"NoAccessToCamera\");\r\nvar NotEnoughGas = createCustomErrorClass(\"NotEnoughGas\");\r\nvar NotSupportedLegacyAddress = createCustomErrorClass(\"NotSupportedLegacyAddress\");\r\nvar GasLessThanEstimate = createCustomErrorClass(\"GasLessThanEstimate\");\r\nvar PasswordsDontMatchError = createCustomErrorClass(\"PasswordsDontMatch\");\r\nvar PasswordIncorrectError = createCustomErrorClass(\"PasswordIncorrect\");\r\nvar RecommendSubAccountsToEmpty = createCustomErrorClass(\"RecommendSubAccountsToEmpty\");\r\nvar RecommendUndelegation = createCustomErrorClass(\"RecommendUndelegation\");\r\nvar TimeoutTagged = createCustomErrorClass(\"TimeoutTagged\");\r\nvar UnexpectedBootloader = createCustomErrorClass(\"UnexpectedBootloader\");\r\nvar MCUNotGenuineToDashboard = createCustomErrorClass(\"MCUNotGenuineToDashboard\");\r\nvar RecipientRequired = createCustomErrorClass(\"RecipientRequired\");\r\nvar UnavailableTezosOriginatedAccountReceive = createCustomErrorClass(\"UnavailableTezosOriginatedAccountReceive\");\r\nvar UnavailableTezosOriginatedAccountSend = createCustomErrorClass(\"UnavailableTezosOriginatedAccountSend\");\r\nvar UpdateFetchFileFail = createCustomErrorClass(\"UpdateFetchFileFail\");\r\nvar UpdateIncorrectHash = createCustomErrorClass(\"UpdateIncorrectHash\");\r\nvar UpdateIncorrectSig = createCustomErrorClass(\"UpdateIncorrectSig\");\r\nvar UpdateYourApp = createCustomErrorClass(\"UpdateYourApp\");\r\nvar UserRefusedDeviceNameChange = createCustomErrorClass(\"UserRefusedDeviceNameChange\");\r\nvar UserRefusedAddress = createCustomErrorClass(\"UserRefusedAddress\");\r\nvar UserRefusedFirmwareUpdate = createCustomErrorClass(\"UserRefusedFirmwareUpdate\");\r\nvar UserRefusedAllowManager = createCustomErrorClass(\"UserRefusedAllowManager\");\r\nvar UserRefusedOnDevice = createCustomErrorClass(\"UserRefusedOnDevice\"); // TODO rename because it's just for transaction refusal\r\nvar TransportOpenUserCancelled = createCustomErrorClass(\"TransportOpenUserCancelled\");\r\nvar TransportInterfaceNotAvailable = createCustomErrorClass(\"TransportInterfaceNotAvailable\");\r\nvar TransportRaceCondition = createCustomErrorClass(\"TransportRaceCondition\");\r\nvar TransportWebUSBGestureRequired = createCustomErrorClass(\"TransportWebUSBGestureRequired\");\r\nvar DeviceShouldStayInApp = createCustomErrorClass(\"DeviceShouldStayInApp\");\r\nvar WebsocketConnectionError = createCustomErrorClass(\"WebsocketConnectionError\");\r\nvar WebsocketConnectionFailed = createCustomErrorClass(\"WebsocketConnectionFailed\");\r\nvar WrongDeviceForAccount = createCustomErrorClass(\"WrongDeviceForAccount\");\r\nvar WrongAppForCurrency = createCustomErrorClass(\"WrongAppForCurrency\");\r\nvar ETHAddressNonEIP = createCustomErrorClass(\"ETHAddressNonEIP\");\r\nvar CantScanQRCode = createCustomErrorClass(\"CantScanQRCode\");\r\nvar FeeNotLoaded = createCustomErrorClass(\"FeeNotLoaded\");\r\nvar FeeRequired = createCustomErrorClass(\"FeeRequired\");\r\nvar FeeTooHigh = createCustomErrorClass(\"FeeTooHigh\");\r\nvar SyncError = createCustomErrorClass(\"SyncError\");\r\nvar PairingFailed = createCustomErrorClass(\"PairingFailed\");\r\nvar GenuineCheckFailed = createCustomErrorClass(\"GenuineCheckFailed\");\r\nvar LedgerAPI4xx = createCustomErrorClass(\"LedgerAPI4xx\");\r\nvar LedgerAPI5xx = createCustomErrorClass(\"LedgerAPI5xx\");\r\nvar FirmwareOrAppUpdateRequired = createCustomErrorClass(\"FirmwareOrAppUpdateRequired\");\r\n// db stuff, no need to translate\r\nvar NoDBPathGiven = createCustomErrorClass(\"NoDBPathGiven\");\r\nvar DBWrongPassword = createCustomErrorClass(\"DBWrongPassword\");\r\nvar DBNotReset = createCustomErrorClass(\"DBNotReset\");\r\n/**\r\n * TransportError is used for any generic transport errors.\r\n * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.\r\n */\r\nfunction TransportError(message, id) {\r\n    this.name = \"TransportError\";\r\n    this.message = message;\r\n    this.stack = new Error().stack;\r\n    this.id = id;\r\n}\r\nTransportError.prototype = new Error();\r\naddCustomErrorDeserializer(\"TransportError\", function (e) { return new TransportError(e.message, e.id); });\r\nvar StatusCodes = {\r\n    PIN_REMAINING_ATTEMPTS: 0x63c0,\r\n    INCORRECT_LENGTH: 0x6700,\r\n    MISSING_CRITICAL_PARAMETER: 0x6800,\r\n    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,\r\n    SECURITY_STATUS_NOT_SATISFIED: 0x6982,\r\n    CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,\r\n    INCORRECT_DATA: 0x6a80,\r\n    NOT_ENOUGH_MEMORY_SPACE: 0x6a84,\r\n    REFERENCED_DATA_NOT_FOUND: 0x6a88,\r\n    FILE_ALREADY_EXISTS: 0x6a89,\r\n    INCORRECT_P1_P2: 0x6b00,\r\n    INS_NOT_SUPPORTED: 0x6d00,\r\n    CLA_NOT_SUPPORTED: 0x6e00,\r\n    TECHNICAL_PROBLEM: 0x6f00,\r\n    OK: 0x9000,\r\n    MEMORY_PROBLEM: 0x9240,\r\n    NO_EF_SELECTED: 0x9400,\r\n    INVALID_OFFSET: 0x9402,\r\n    FILE_NOT_FOUND: 0x9404,\r\n    INCONSISTENT_FILE: 0x9408,\r\n    ALGORITHM_NOT_SUPPORTED: 0x9484,\r\n    INVALID_KCV: 0x9485,\r\n    CODE_NOT_INITIALIZED: 0x9802,\r\n    ACCESS_CONDITION_NOT_FULFILLED: 0x9804,\r\n    CONTRADICTION_SECRET_CODE_STATUS: 0x9808,\r\n    CONTRADICTION_INVALIDATION: 0x9810,\r\n    CODE_BLOCKED: 0x9840,\r\n    MAX_VALUE_REACHED: 0x9850,\r\n    GP_AUTH_FAILED: 0x6300,\r\n    LICENSING: 0x6f42,\r\n    HALTED: 0x6faa,\r\n};\r\nfunction getAltStatusMessage(code) {\r\n    switch (code) {\r\n        // improve text of most common errors\r\n        case 0x6700:\r\n            return \"Incorrect length\";\r\n        case 0x6800:\r\n            return \"Missing critical parameter\";\r\n        case 0x6982:\r\n            return \"Security not satisfied (dongle locked or have invalid access rights)\";\r\n        case 0x6985:\r\n            return \"Condition of use not satisfied (denied by the user?)\";\r\n        case 0x6a80:\r\n            return \"Invalid data received\";\r\n        case 0x6b00:\r\n            return \"Invalid parameter received\";\r\n    }\r\n    if (0x6f00 <= code && code <= 0x6fff) {\r\n        return \"Internal error, please report\";\r\n    }\r\n}\r\n/**\r\n * Error thrown when a device returned a non success status.\r\n * the error.statusCode is one of the `StatusCodes` exported by this library.\r\n */\r\nfunction TransportStatusError(statusCode) {\r\n    this.name = \"TransportStatusError\";\r\n    var statusText = Object.keys(StatusCodes).find(function (k) { return StatusCodes[k] === statusCode; }) ||\r\n        \"UNKNOWN_ERROR\";\r\n    var smsg = getAltStatusMessage(statusCode) || statusText;\r\n    var statusCodeStr = statusCode.toString(16);\r\n    this.message = \"Ledger device: \" + smsg + \" (0x\" + statusCodeStr + \")\";\r\n    this.stack = new Error().stack;\r\n    this.statusCode = statusCode;\r\n    this.statusText = statusText;\r\n}\r\nTransportStatusError.prototype = new Error();\r\naddCustomErrorDeserializer(\"TransportStatusError\", function (e) { return new TransportStatusError(e.statusCode); });\n\nexport { AccountNameRequiredError, AccountNotSupported, AmountRequired, BluetoothRequired, BtcUnmatchedApp, CantOpenDevice, CantScanQRCode, CashAddrNotSupported, CurrencyNotSupported, DBNotReset, DBWrongPassword, DeviceAppVerifyNotSupported, DeviceGenuineSocketEarlyClose, DeviceHalted, DeviceInOSUExpected, DeviceNameInvalid, DeviceNotGenuineError, DeviceOnDashboardExpected, DeviceOnDashboardUnexpected, DeviceShouldStayInApp, DeviceSocketFail, DeviceSocketNoBulkStatus, DisconnectedDevice, DisconnectedDeviceDuringOperation, ETHAddressNonEIP, EnpointConfigError, EthAppPleaseEnableContractData, FeeEstimationFailed, FeeNotLoaded, FeeRequired, FeeTooHigh, FirmwareNotRecognized, FirmwareOrAppUpdateRequired, GasLessThanEstimate, GenuineCheckFailed, HardResetFail, InvalidAddress, InvalidAddressBecauseDestinationIsAlsoSource, InvalidXRPTag, LatestMCUInstalledError, LedgerAPI4xx, LedgerAPI5xx, LedgerAPIError, LedgerAPIErrorWithMessage, LedgerAPINotAvailable, MCUNotGenuineToDashboard, ManagerAppAlreadyInstalledError, ManagerAppDepInstallRequired, ManagerAppDepUninstallRequired, ManagerAppRelyOnBTCError, ManagerDeviceLockedError, ManagerFirmwareNotEnoughSpaceError, ManagerNotEnoughSpaceError, ManagerUninstallBTCDep, NetworkDown, NoAccessToCamera, NoAddressesFound, NoDBPathGiven, NotEnoughBalance, NotEnoughBalanceBecauseDestinationNotCreated, NotEnoughBalanceInParentAccount, NotEnoughBalanceToDelegate, NotEnoughGas, NotEnoughSpendableBalance, NotSupportedLegacyAddress, PairingFailed, PasswordIncorrectError, PasswordsDontMatchError, RecipientRequired, RecommendSubAccountsToEmpty, RecommendUndelegation, StatusCodes, SyncError, TimeoutTagged, TransportError, TransportInterfaceNotAvailable, TransportOpenUserCancelled, TransportRaceCondition, TransportStatusError, TransportWebUSBGestureRequired, UnavailableTezosOriginatedAccountReceive, UnavailableTezosOriginatedAccountSend, UnexpectedBootloader, UnknownMCU, UpdateFetchFileFail, UpdateIncorrectHash, UpdateIncorrectSig, UpdateYourApp, UserRefusedAddress, UserRefusedAllowManager, UserRefusedDeviceNameChange, UserRefusedFirmwareUpdate, UserRefusedOnDevice, WebsocketConnectionError, WebsocketConnectionFailed, WrongAppForCurrency, WrongDeviceForAccount, addCustomErrorDeserializer, createCustomErrorClass, deserializeError, getAltStatusMessage, serializeError };\n"],"sourceRoot":""}